# Exercise 3

Java EE Development with Docker containers

## What you will learn
Particpants will learn how to switch to a production database such as Postgres. Participants will learn how to package their applications inside their container.

One of the biggest benefits of a Docker container is that it allows you to work in an environment much closer to your production environment. Up until now we've been using the H2 in memory database, and deploying our application to the container from the command line. Of course, this isn't what happens for real projects, where you need to use a RDBMS, and you want to build your application in a reproducible fashion, tagging source and binaries as you go.

## Prerequisites

* Participants should successfully have executed exercise 2
* Participatns should have cleaned up any running containers

NOTE: To clean up all the running container run the following command `docker stop $(docker ps -q) && docker rm $(docker ps -aq)`.

### Switching to postgres
These steps are all done on the particpants desktop.

Step 1 - Run the postgres container::
We're going to use the postgres container from the docker registry. For extra points, you might wish to build your own, or make some modifications by creating a layer on top.
+
[source,shell,numbered]
----
docker run --name db -i -p 5432:5432 -e POSTGRES_USER=ticketmonster -e POSTGRES_PASSWORD=ticketmonster-docker postgres
----
+
If you've been paying attention, you'll notice that in addition to the usual port mappings, environment variables and container tag, we've specified a container name `db`. We'll use this in just a minute to *link* the application server to the database server.
+
You may also be wondering why we don't just put the database server in the same container as the application server. Whilst you might be tempted to do this with a VM, containers are so lightweight there really is no need. The benefits of the isolation you get from using multiple containers vastly outweighs any complexity incurred.

Step 2 - Modify the application server to use Postgres::

We'll reuse the Dockerfile you created for Ticket Monster in Exercise 2, and modify it to support Postgres. We have provided a CLI batch script, the postgres JDBC driver, and a bash script that you can execute when the Docker container is being built. The bash script will copy the Postgres JDBC driver, bring up the JBoss EAP server, execute the CLI script, and then shut the server down.
+
Edit the `Dockerfile` you created in Exercise 2, and add the following lines after the `MAINTAINER` line:
+
----
# Add customization folder
COPY customization /opt/jboss/wildfly/customization/

USER root

# Run customization scripts as root
RUN chmod +x /opt/jboss/wildfly/customization/execute.sh
RUN /opt/jboss/wildfly/customization/execute.sh standalone standalone-ha.xml
----
+
. Now rebuild the Dockerfile
+
----
docker build -t <your-alias>/jboss-eap:1.0 -f custom-jboss-eap/Dockerfile .
----

Now, we'll use the customized JBoss EAP container, together with container linking, to get TicketMonster using Postgres.x

## Summary
After the second exercise participant should start to feel comfortable with manaing containers locally in a development environment. The most important benefit of running docker in a development environment like this is that the container can be almost identical with the target production environment. Lowering the complexity of Continious Delivery environment, and improving the quality.
