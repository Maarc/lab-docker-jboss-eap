## Exercise 3

This is an intermediate exercise.

### What you will learn
Particpants will learn how to switch to a production database such as Postgres. Participants will learn how to package their applications inside their container.

One of the biggest benefits of a Docker container is that it allows you to work in an environment much closer to your production environment. Up until now we've been using the H2 in memory database, and deploying our application to the container from the command line. Of course, this isn't what happens for real projects, where you need to use a RDBMS, and you want to build your application in a reproducible fashion, tagging source and binaries as you go.

### Prerequisites

* Participants should successfully have executed exercise 2
* Participatns should have cleaned up any running containers

[NOTE]
====
To clean up all the running container run the following command:
[source,bash]
----
docker stop $(docker ps -q) && docker rm $(docker ps -aq)`.
----
====

### Switching to postgres
These steps are all done on the particpants desktop.

Step 1 - Run the PostgreSQL container::
We're going to use the PostgreSQL container from the Docker registry. Launch the container in the background as a daemon using the `-d` flag:
+
[source,bash,numbered]
----
docker run --name ticket-monster-db -e POSTGRES_PASSWORD=UsW4fznqLmGRh6 -d postgres:9.4
----
+
The PostgreSQL Docker container comes with a couple of handy shortcuts. We can specify the password on the `docker run` command, and the container will then automatically create a database called `postgres`, using the `postgres` user, and the specified password.
+
If you've been paying attention, you'll notice that in addition to the usual port mappings, environment variables and container tag, we've specified a container name `ticket-monster-db`. We'll use this in just a minute to *link* the application server to the database server. We'll also use it just a minute when we verify the PostgreSQL server is working. 
+
You may also be wondering why we don't just put the database server in the same container as the application server. Whilst you might be tempted to do this with a VM, containers are so lightweight there really is no need. The benefits of the isolation you get from using multiple containers vastly outweighs any complexity incurred.

Step 2 - Verify PostgreSQL container::
We'll use the `psql` command to interrogate the PostgreSQL container, and make sure it's working. `psql` isn't installed on your workstation so we'll use another docker container to run it, linking to the Postgres container.
+
The first concept we need to understand is how Docker allows linking containers. Creating a link between two containers creates a conduit between a source container and a target container and securely transfer information about source container to target container. In our case, the target container (psql) can see information about source container (PostgreSQL server). The important part to understand here is that none of this information needs to be publicly exposed by the source container, and is only made available to the target container.
+
The magic switch to enable link is, intuitively, `--link`. So for example, if the PostgreSQL and the psql containers are run as shown above, then `--link ticket-monster-db:postgres` links the PostgreSQL container named `ticket-monster-db` with an alias `postgres` to the psql target container. This defines some environment variables, following the defined protocol, in the target container which can then be used to access information about the source container. For example, IP address, exposed ports, username, passwords, etc. The complete list of environment variables can be seen as:
+
[source,bash,numbered]
----
$ docker run -it --link ticket-monster-db:postgres --rm postgres:9.4 env
POSTGRES_PORT=tcp://172.17.0.12:5432
POSTGRES_ENV_POSTGRES_PASSWORD=UsW4fznqLmGRh6
HOSTNAME=63fb3ba7f993
TERM=xterm
PG_MAJOR=9.4
POSTGRES_ENV_LANG=en_US.utf8
POSTGRES_ENV_PG_MAJOR=9.4
POSTGRES_PORT_5432_TCP_PORT=5432
POSTGRES_PORT_5432_TCP_ADDR=172.17.0.12
PATH=/usr/lib/postgresql/9.4/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
POSTGRES_ENV_PGDATA=/var/lib/postgresql/data
PWD=/
LANG=en_US.utf8
container_uuid=63fb3ba7-f993-0863-6d12-daafe7763ef0
POSTGRES_NAME=/loving_jones/postgres
SHLVL=0
HOME=/root
PG_VERSION=9.4.2-1.pgdg70+1
PGDATA=/var/lib/postgresql/data
POSTGRES_PORT_5432_TCP=tcp://172.17.0.12:5432
POSTGRES_PORT_5432_TCP_PROTO=tcp
POSTGRES_ENV_PG_VERSION=9.4.2-1.pgdg70+1
----
+
You can see there are a number of `POSTGRES_*` environment variables providing plenty of information about source container.
+
Linking only works if all the containers are running on the same host.
+
Let's try it out. Run the following command to execute `psql` against the PostgreSQL server:
+
[source,bash,numbered]
----
docker run -it --link ticket-monster-db:postgres --rm postgres:9.4 sh -c 'exec psql -h "$POSTGRES_PORT_5432_TCP_ADDR" -p "$POSTGRES_PORT_5432_TCP_PORT" -U postgres'
----
+
When asked for a password enter `UsW4fznqLmGRh6`. You should now see the psql console:
+
[source,bash,numbered]
----
psql (9.4.2)
Type "help" for help.

postgres=#
----
+
Let's check what's in the (currently empty) database:
+
----
postgres=# \l
                                 List of databases
   Name    |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges   
-----------+----------+----------+------------+------------+-----------------------
 postgres  | postgres | UTF8     | en_US.utf8 | en_US.utf8 | 
 template0 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
           |          |          |            |            | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
           |          |          |            |            | postgres=CTc/postgres
(3 rows)

postgres=# \connect postgres
You are now connected to database "postgres" as user "postgres".
postgres=# \dt
No relations found.
postgres=# 
----
+
Leave this terminal running, and use another for the next steps - we'll want to use the psql console again in just a minute.

Step 3 - Modify the application server to use Postgres::

We'll reuse the `Dockerfile` you created for Ticket Monster in Exercise 2, and modify it to support PostgreSQL. We have provided a bash script that will modify JBoss EAP on start to add the PostgreSQL driver and datasource. The script waits for EAP to start, runs some JBoss EAP CLI commands, and the restarts the server.
+
Now's a great time to introduce you to one of the core concepts in Docker - layering. A Docker image is made up of multiple layers where each layer provides some functionality, and a higher layer can add functionality on top of it. For example, Docker mounts the root filesystem as read-only layer and then adds a read-write layer on top of it. All these layers are combined together using Union Mount to provide application operating environment.
+
We'll use the concept of layering to extend the `Dockerfile` you created in Exercise 2 to execute the bash script that adds Postgres.
+
Create a new directory called `custom-jboss-eap-postgres/`, and add a `Dockerfile` that looks like:
+
----
# The layer on which we will build
FROM <your-alias>/jboss-eap:1.0

# Get the custom start script, which will install PostgreSQL. You can view this URL in your web browser if you are curious
RUN mkdir -p /opt/eap/customization/
RUN curl -L http://classroom.example.com:5002/docker-jboss-eap/lab/postgres/execute.sh > /opt/eap/customization/execute.sh

RUN chmod u+x /opt/eap/customization/execute.sh

# Start JBoss EAP using the custom script
CMD ["/opt/eap/customization/execute.sh"]
----
+
Of course, you need to replace <your-alias> with your name. Now, build your new docker container
+
----
docker build -t <your-alias>/jboss-eap-postgres:1.0 -f custom-jboss-eap-postgres/Dockerfile .
----
+
Now, we'll use the customized JBoss EAP container, together with container linking, to make TicketMonster using Postgres.

Step 5 - Start the application server, deploy your application and verify data is stored in Postgres::

First, bring up JBoss EAP. Add a `--link` option to allow the PostgreSQL container to be accessed:
+
----
docker run -i -p 8081:8080 -p 9990:9990 -p 9999:9999 --link ticket-monster-db:postgres <your-alias>/jboss-eap-postgres:1.0
----

Step 4 - Deploy TicketMonster to the application server and verify the use of PostgreSQL::

TicketMonster comes with built in support for PostgreSQL, so all we have to do is build using the `postgresql` profile
+
[source,bash]
----
$ mvn clean package -Ppostgresql jboss-as:deploy
----

### Summary
After the third exercise participant should start to feel comfortable with layering containers, linking containers, and understanding when, how and why you package your application in the container.
